// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pb/configmap.v1.proto

package pb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ListConfigMapsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListConfigMapsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConfigMapsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListConfigMapsRequestMultiError, or nil if none found.
func (m *ListConfigMapsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConfigMapsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := ListConfigMapsRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := ListConfigMapsRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Keyword

	// no validation rules for Page

	// no validation rules for PageSize

	// no validation rules for ListAll

	if len(errors) > 0 {
		return ListConfigMapsRequestMultiError(errors)
	}

	return nil
}

// ListConfigMapsRequestMultiError is an error wrapping multiple validation
// errors returned by ListConfigMapsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListConfigMapsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConfigMapsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConfigMapsRequestMultiError) AllErrors() []error { return m }

// ListConfigMapsRequestValidationError is the validation error returned by
// ListConfigMapsRequest.Validate if the designated constraints aren't met.
type ListConfigMapsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConfigMapsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConfigMapsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConfigMapsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConfigMapsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConfigMapsRequestValidationError) ErrorName() string {
	return "ListConfigMapsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListConfigMapsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConfigMapsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConfigMapsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConfigMapsRequestValidationError{}

// Validate checks the field values on ConfigMapReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigMapReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigMapReferenceMultiError, or nil if none found.
func (m *ConfigMapReference) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for Name

	if len(errors) > 0 {
		return ConfigMapReferenceMultiError(errors)
	}

	return nil
}

// ConfigMapReferenceMultiError is an error wrapping multiple validation errors
// returned by ConfigMapReference.ValidateAll() if the designated constraints
// aren't met.
type ConfigMapReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapReferenceMultiError) AllErrors() []error { return m }

// ConfigMapReferenceValidationError is the validation error returned by
// ConfigMapReference.Validate if the designated constraints aren't met.
type ConfigMapReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapReferenceValidationError) ErrorName() string {
	return "ConfigMapReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigMapReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapReferenceValidationError{}

// Validate checks the field values on ConfigMapItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigMapItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigMapItemMultiError, or
// nil if none found.
func (m *ConfigMapItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ConfigMapItemValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RefCount

	// no validation rules for Labels

	// no validation rules for Annotations

	if m.GetCreateTime() < 1 {
		err := ConfigMapItemValidationError{
			field:  "CreateTime",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdateTime() < 1 {
		err := ConfigMapItemValidationError{
			field:  "UpdateTime",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Data

	if utf8.RuneCountInString(m.GetYaml()) < 1 {
		err := ConfigMapItemValidationError{
			field:  "Yaml",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetRefs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigMapItemValidationError{
						field:  fmt.Sprintf("Refs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigMapItemValidationError{
						field:  fmt.Sprintf("Refs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigMapItemValidationError{
					field:  fmt.Sprintf("Refs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsFollowed

	if len(errors) > 0 {
		return ConfigMapItemMultiError(errors)
	}

	return nil
}

// ConfigMapItemMultiError is an error wrapping multiple validation errors
// returned by ConfigMapItem.ValidateAll() if the designated constraints
// aren't met.
type ConfigMapItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapItemMultiError) AllErrors() []error { return m }

// ConfigMapItemValidationError is the validation error returned by
// ConfigMapItem.Validate if the designated constraints aren't met.
type ConfigMapItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapItemValidationError) ErrorName() string { return "ConfigMapItemValidationError" }

// Error satisfies the builtin error interface
func (e ConfigMapItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapItemValidationError{}

// Validate checks the field values on ListConfigMapsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListConfigMapsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListConfigMapsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListConfigMapsResponseMultiError, or nil if none found.
func (m *ListConfigMapsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListConfigMapsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Total

	for idx, item := range m.GetList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListConfigMapsResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListConfigMapsResponseValidationError{
						field:  fmt.Sprintf("List[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListConfigMapsResponseValidationError{
					field:  fmt.Sprintf("List[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListConfigMapsResponseMultiError(errors)
	}

	return nil
}

// ListConfigMapsResponseMultiError is an error wrapping multiple validation
// errors returned by ListConfigMapsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListConfigMapsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConfigMapsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConfigMapsResponseMultiError) AllErrors() []error { return m }

// ListConfigMapsResponseValidationError is the validation error returned by
// ListConfigMapsResponse.Validate if the designated constraints aren't met.
type ListConfigMapsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConfigMapsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConfigMapsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConfigMapsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConfigMapsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConfigMapsResponseValidationError) ErrorName() string {
	return "ListConfigMapsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListConfigMapsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConfigMapsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConfigMapsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConfigMapsResponseValidationError{}

// Validate checks the field values on CreateOrUpdateConfigMapByYamlRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateOrUpdateConfigMapByYamlRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrUpdateConfigMapByYamlRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateOrUpdateConfigMapByYamlRequestMultiError, or nil if none found.
func (m *CreateOrUpdateConfigMapByYamlRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateConfigMapByYamlRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := CreateOrUpdateConfigMapByYamlRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetYaml()) < 1 {
		err := CreateOrUpdateConfigMapByYamlRequestValidationError{
			field:  "Yaml",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateOrUpdateConfigMapByYamlRequestMultiError(errors)
	}

	return nil
}

// CreateOrUpdateConfigMapByYamlRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateOrUpdateConfigMapByYamlRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateOrUpdateConfigMapByYamlRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateConfigMapByYamlRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateConfigMapByYamlRequestMultiError) AllErrors() []error { return m }

// CreateOrUpdateConfigMapByYamlRequestValidationError is the validation error
// returned by CreateOrUpdateConfigMapByYamlRequest.Validate if the designated
// constraints aren't met.
type CreateOrUpdateConfigMapByYamlRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateConfigMapByYamlRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateConfigMapByYamlRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateConfigMapByYamlRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateConfigMapByYamlRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateConfigMapByYamlRequestValidationError) ErrorName() string {
	return "CreateOrUpdateConfigMapByYamlRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateConfigMapByYamlRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateConfigMapByYamlRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateConfigMapByYamlRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateConfigMapByYamlRequestValidationError{}

// Validate checks the field values on CreateOrUpdateConfigMapByYamlResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateOrUpdateConfigMapByYamlResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateOrUpdateConfigMapByYamlResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateOrUpdateConfigMapByYamlResponseMultiError, or nil if none found.
func (m *CreateOrUpdateConfigMapByYamlResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateOrUpdateConfigMapByYamlResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateOrUpdateConfigMapByYamlResponseMultiError(errors)
	}

	return nil
}

// CreateOrUpdateConfigMapByYamlResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateOrUpdateConfigMapByYamlResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateOrUpdateConfigMapByYamlResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateOrUpdateConfigMapByYamlResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateOrUpdateConfigMapByYamlResponseMultiError) AllErrors() []error { return m }

// CreateOrUpdateConfigMapByYamlResponseValidationError is the validation error
// returned by CreateOrUpdateConfigMapByYamlResponse.Validate if the
// designated constraints aren't met.
type CreateOrUpdateConfigMapByYamlResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateOrUpdateConfigMapByYamlResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateOrUpdateConfigMapByYamlResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateOrUpdateConfigMapByYamlResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateOrUpdateConfigMapByYamlResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateOrUpdateConfigMapByYamlResponseValidationError) ErrorName() string {
	return "CreateOrUpdateConfigMapByYamlResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateOrUpdateConfigMapByYamlResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateOrUpdateConfigMapByYamlResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateOrUpdateConfigMapByYamlResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateOrUpdateConfigMapByYamlResponseValidationError{}

// Validate checks the field values on DeleteConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConfigMapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConfigMapRequestMultiError, or nil if none found.
func (m *DeleteConfigMapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConfigMapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := DeleteConfigMapRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := DeleteConfigMapRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := DeleteConfigMapRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteConfigMapRequestMultiError(errors)
	}

	return nil
}

// DeleteConfigMapRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteConfigMapRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteConfigMapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConfigMapRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConfigMapRequestMultiError) AllErrors() []error { return m }

// DeleteConfigMapRequestValidationError is the validation error returned by
// DeleteConfigMapRequest.Validate if the designated constraints aren't met.
type DeleteConfigMapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConfigMapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConfigMapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConfigMapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConfigMapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConfigMapRequestValidationError) ErrorName() string {
	return "DeleteConfigMapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConfigMapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConfigMapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConfigMapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConfigMapRequestValidationError{}

// Validate checks the field values on DeleteConfigMapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteConfigMapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteConfigMapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteConfigMapResponseMultiError, or nil if none found.
func (m *DeleteConfigMapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteConfigMapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteConfigMapResponseMultiError(errors)
	}

	return nil
}

// DeleteConfigMapResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteConfigMapResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteConfigMapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConfigMapResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConfigMapResponseMultiError) AllErrors() []error { return m }

// DeleteConfigMapResponseValidationError is the validation error returned by
// DeleteConfigMapResponse.Validate if the designated constraints aren't met.
type DeleteConfigMapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConfigMapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConfigMapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConfigMapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConfigMapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConfigMapResponseValidationError) ErrorName() string {
	return "DeleteConfigMapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConfigMapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConfigMapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConfigMapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConfigMapResponseValidationError{}

// Validate checks the field values on ConfigMapDetailRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigMapDetailRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapDetailRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigMapDetailRequestMultiError, or nil if none found.
func (m *ConfigMapDetailRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapDetailRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := ConfigMapDetailRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := ConfigMapDetailRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := ConfigMapDetailRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConfigMapDetailRequestMultiError(errors)
	}

	return nil
}

// ConfigMapDetailRequestMultiError is an error wrapping multiple validation
// errors returned by ConfigMapDetailRequest.ValidateAll() if the designated
// constraints aren't met.
type ConfigMapDetailRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapDetailRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapDetailRequestMultiError) AllErrors() []error { return m }

// ConfigMapDetailRequestValidationError is the validation error returned by
// ConfigMapDetailRequest.Validate if the designated constraints aren't met.
type ConfigMapDetailRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapDetailRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapDetailRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapDetailRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapDetailRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapDetailRequestValidationError) ErrorName() string {
	return "ConfigMapDetailRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigMapDetailRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapDetailRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapDetailRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapDetailRequestValidationError{}

// Validate checks the field values on ConfigMapDetailResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConfigMapDetailResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapDetailResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConfigMapDetailResponseMultiError, or nil if none found.
func (m *ConfigMapDetailResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapDetailResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDetail()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigMapDetailResponseValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigMapDetailResponseValidationError{
					field:  "Detail",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetail()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigMapDetailResponseValidationError{
				field:  "Detail",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConfigMapDetailResponseMultiError(errors)
	}

	return nil
}

// ConfigMapDetailResponseMultiError is an error wrapping multiple validation
// errors returned by ConfigMapDetailResponse.ValidateAll() if the designated
// constraints aren't met.
type ConfigMapDetailResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapDetailResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapDetailResponseMultiError) AllErrors() []error { return m }

// ConfigMapDetailResponseValidationError is the validation error returned by
// ConfigMapDetailResponse.Validate if the designated constraints aren't met.
type ConfigMapDetailResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapDetailResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapDetailResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapDetailResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapDetailResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapDetailResponseValidationError) ErrorName() string {
	return "ConfigMapDetailResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ConfigMapDetailResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapDetailResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapDetailResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapDetailResponseValidationError{}

// Validate checks the field values on CreateConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConfigMapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConfigMapRequestMultiError, or nil if none found.
func (m *CreateConfigMapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConfigMapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := CreateConfigMapRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := CreateConfigMapRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := CreateConfigMapRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	// no validation rules for Annotations

	// no validation rules for Data

	if len(errors) > 0 {
		return CreateConfigMapRequestMultiError(errors)
	}

	return nil
}

// CreateConfigMapRequestMultiError is an error wrapping multiple validation
// errors returned by CreateConfigMapRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateConfigMapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConfigMapRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConfigMapRequestMultiError) AllErrors() []error { return m }

// CreateConfigMapRequestValidationError is the validation error returned by
// CreateConfigMapRequest.Validate if the designated constraints aren't met.
type CreateConfigMapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConfigMapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConfigMapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConfigMapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConfigMapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConfigMapRequestValidationError) ErrorName() string {
	return "CreateConfigMapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConfigMapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConfigMapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConfigMapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConfigMapRequestValidationError{}

// Validate checks the field values on CreateConfigMapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConfigMapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConfigMapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConfigMapResponseMultiError, or nil if none found.
func (m *CreateConfigMapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConfigMapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CreateConfigMapResponseMultiError(errors)
	}

	return nil
}

// CreateConfigMapResponseMultiError is an error wrapping multiple validation
// errors returned by CreateConfigMapResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateConfigMapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConfigMapResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConfigMapResponseMultiError) AllErrors() []error { return m }

// CreateConfigMapResponseValidationError is the validation error returned by
// CreateConfigMapResponse.Validate if the designated constraints aren't met.
type CreateConfigMapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConfigMapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConfigMapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConfigMapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConfigMapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConfigMapResponseValidationError) ErrorName() string {
	return "CreateConfigMapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConfigMapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConfigMapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConfigMapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConfigMapResponseValidationError{}

// Validate checks the field values on UpdateConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConfigMapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConfigMapRequestMultiError, or nil if none found.
func (m *UpdateConfigMapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConfigMapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := UpdateConfigMapRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNamespace()) < 1 {
		err := UpdateConfigMapRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := UpdateConfigMapRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Labels

	// no validation rules for Annotations

	// no validation rules for Data

	if len(errors) > 0 {
		return UpdateConfigMapRequestMultiError(errors)
	}

	return nil
}

// UpdateConfigMapRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateConfigMapRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateConfigMapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConfigMapRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConfigMapRequestMultiError) AllErrors() []error { return m }

// UpdateConfigMapRequestValidationError is the validation error returned by
// UpdateConfigMapRequest.Validate if the designated constraints aren't met.
type UpdateConfigMapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConfigMapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConfigMapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConfigMapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConfigMapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConfigMapRequestValidationError) ErrorName() string {
	return "UpdateConfigMapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConfigMapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConfigMapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConfigMapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConfigMapRequestValidationError{}

// Validate checks the field values on UpdateConfigMapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateConfigMapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateConfigMapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateConfigMapResponseMultiError, or nil if none found.
func (m *UpdateConfigMapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateConfigMapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateConfigMapResponseMultiError(errors)
	}

	return nil
}

// UpdateConfigMapResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateConfigMapResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateConfigMapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateConfigMapResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateConfigMapResponseMultiError) AllErrors() []error { return m }

// UpdateConfigMapResponseValidationError is the validation error returned by
// UpdateConfigMapResponse.Validate if the designated constraints aren't met.
type UpdateConfigMapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateConfigMapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateConfigMapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateConfigMapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateConfigMapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateConfigMapResponseValidationError) ErrorName() string {
	return "UpdateConfigMapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateConfigMapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateConfigMapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateConfigMapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateConfigMapResponseValidationError{}
