// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.27.2
// source: pb/crr.v1.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	CRR_GetCRRDetail_FullMethodName   = "/crr.v1.CRR/GetCRRDetail"
	CRR_BatchCreateCrr_FullMethodName = "/crr.v1.CRR/BatchCreateCrr"
	CRR_BatchQueryCRR_FullMethodName  = "/crr.v1.CRR/BatchQueryCRR"
	CRR_CreateCrr_FullMethodName      = "/crr.v1.CRR/CreateCrr"
)

// CRRClient is the client API for CRR service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CRRClient interface {
	// 查看-云原生管理-CRR-详情
	GetCRRDetail(ctx context.Context, in *GetCRRDetailRequest, opts ...grpc.CallOption) (*GetCRRDetailResponse, error)
	// 管理-云原生管理-CRR-批量创建
	BatchCreateCrr(ctx context.Context, in *BatchCreateCRRRequest, opts ...grpc.CallOption) (*BatchCreateCRRResponse, error)
	// 查看-云原生管理-CRR-批量查询重启状态
	BatchQueryCRR(ctx context.Context, in *GetBatchCRRDetailRequest, opts ...grpc.CallOption) (*GetBatchCRRDetailResponse, error)
	// 管理-云原生管理-CRR-创建
	CreateCrr(ctx context.Context, in *CreateCRRRequest, opts ...grpc.CallOption) (*CreateCRRResponse, error)
}

type cRRClient struct {
	cc grpc.ClientConnInterface
}

func NewCRRClient(cc grpc.ClientConnInterface) CRRClient {
	return &cRRClient{cc}
}

func (c *cRRClient) GetCRRDetail(ctx context.Context, in *GetCRRDetailRequest, opts ...grpc.CallOption) (*GetCRRDetailResponse, error) {
	out := new(GetCRRDetailResponse)
	err := c.cc.Invoke(ctx, CRR_GetCRRDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cRRClient) BatchCreateCrr(ctx context.Context, in *BatchCreateCRRRequest, opts ...grpc.CallOption) (*BatchCreateCRRResponse, error) {
	out := new(BatchCreateCRRResponse)
	err := c.cc.Invoke(ctx, CRR_BatchCreateCrr_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cRRClient) BatchQueryCRR(ctx context.Context, in *GetBatchCRRDetailRequest, opts ...grpc.CallOption) (*GetBatchCRRDetailResponse, error) {
	out := new(GetBatchCRRDetailResponse)
	err := c.cc.Invoke(ctx, CRR_BatchQueryCRR_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cRRClient) CreateCrr(ctx context.Context, in *CreateCRRRequest, opts ...grpc.CallOption) (*CreateCRRResponse, error) {
	out := new(CreateCRRResponse)
	err := c.cc.Invoke(ctx, CRR_CreateCrr_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CRRServer is the server API for CRR service.
// All implementations must embed UnimplementedCRRServer
// for forward compatibility
type CRRServer interface {
	// 查看-云原生管理-CRR-详情
	GetCRRDetail(context.Context, *GetCRRDetailRequest) (*GetCRRDetailResponse, error)
	// 管理-云原生管理-CRR-批量创建
	BatchCreateCrr(context.Context, *BatchCreateCRRRequest) (*BatchCreateCRRResponse, error)
	// 查看-云原生管理-CRR-批量查询重启状态
	BatchQueryCRR(context.Context, *GetBatchCRRDetailRequest) (*GetBatchCRRDetailResponse, error)
	// 管理-云原生管理-CRR-创建
	CreateCrr(context.Context, *CreateCRRRequest) (*CreateCRRResponse, error)
	mustEmbedUnimplementedCRRServer()
}

// UnimplementedCRRServer must be embedded to have forward compatible implementations.
type UnimplementedCRRServer struct {
}

func (UnimplementedCRRServer) GetCRRDetail(context.Context, *GetCRRDetailRequest) (*GetCRRDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCRRDetail not implemented")
}
func (UnimplementedCRRServer) BatchCreateCrr(context.Context, *BatchCreateCRRRequest) (*BatchCreateCRRResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateCrr not implemented")
}
func (UnimplementedCRRServer) BatchQueryCRR(context.Context, *GetBatchCRRDetailRequest) (*GetBatchCRRDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchQueryCRR not implemented")
}
func (UnimplementedCRRServer) CreateCrr(context.Context, *CreateCRRRequest) (*CreateCRRResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCrr not implemented")
}
func (UnimplementedCRRServer) mustEmbedUnimplementedCRRServer() {}

// UnsafeCRRServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CRRServer will
// result in compilation errors.
type UnsafeCRRServer interface {
	mustEmbedUnimplementedCRRServer()
}

func RegisterCRRServer(s grpc.ServiceRegistrar, srv CRRServer) {
	s.RegisterService(&CRR_ServiceDesc, srv)
}

func _CRR_GetCRRDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCRRDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CRRServer).GetCRRDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CRR_GetCRRDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CRRServer).GetCRRDetail(ctx, req.(*GetCRRDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CRR_BatchCreateCrr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateCRRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CRRServer).BatchCreateCrr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CRR_BatchCreateCrr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CRRServer).BatchCreateCrr(ctx, req.(*BatchCreateCRRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CRR_BatchQueryCRR_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBatchCRRDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CRRServer).BatchQueryCRR(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CRR_BatchQueryCRR_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CRRServer).BatchQueryCRR(ctx, req.(*GetBatchCRRDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CRR_CreateCrr_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCRRRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CRRServer).CreateCrr(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CRR_CreateCrr_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CRRServer).CreateCrr(ctx, req.(*CreateCRRRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CRR_ServiceDesc is the grpc.ServiceDesc for CRR service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CRR_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "crr.v1.CRR",
	HandlerType: (*CRRServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCRRDetail",
			Handler:    _CRR_GetCRRDetail_Handler,
		},
		{
			MethodName: "BatchCreateCrr",
			Handler:    _CRR_BatchCreateCrr_Handler,
		},
		{
			MethodName: "BatchQueryCRR",
			Handler:    _CRR_BatchQueryCRR_Handler,
		},
		{
			MethodName: "CreateCrr",
			Handler:    _CRR_CreateCrr_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/crr.v1.proto",
}
