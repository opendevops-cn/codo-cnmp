// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.27.2
// source: pb/configmap.v1.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ConfigMap_ListConfigMap_FullMethodName                 = "/configmap.v1.ConfigMap/ListConfigMap"
	ConfigMap_CreateOrUpdateConfigMapByYaml_FullMethodName = "/configmap.v1.ConfigMap/CreateOrUpdateConfigMapByYaml"
	ConfigMap_DeleteConfigMap_FullMethodName               = "/configmap.v1.ConfigMap/DeleteConfigMap"
	ConfigMap_GetConfigMapDetail_FullMethodName            = "/configmap.v1.ConfigMap/GetConfigMapDetail"
	ConfigMap_CreateConfigMap_FullMethodName               = "/configmap.v1.ConfigMap/CreateConfigMap"
	ConfigMap_UpdateConfigMap_FullMethodName               = "/configmap.v1.ConfigMap/UpdateConfigMap"
)

// ConfigMapClient is the client API for ConfigMap service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConfigMapClient interface {
	// 查看-云原生管理-ConfigMap-列表
	ListConfigMap(ctx context.Context, in *ListConfigMapsRequest, opts ...grpc.CallOption) (*ListConfigMapsResponse, error)
	// 管理-云原生管理-ConfigMap-Yaml创建更新
	CreateOrUpdateConfigMapByYaml(ctx context.Context, in *CreateOrUpdateConfigMapByYamlRequest, opts ...grpc.CallOption) (*CreateOrUpdateConfigMapByYamlResponse, error)
	// 管理-云原生管理-ConfigMap-删除
	DeleteConfigMap(ctx context.Context, in *DeleteConfigMapRequest, opts ...grpc.CallOption) (*DeleteConfigMapResponse, error)
	// 查看-云原生管理-ConfigMap-详情
	GetConfigMapDetail(ctx context.Context, in *ConfigMapDetailRequest, opts ...grpc.CallOption) (*ConfigMapDetailResponse, error)
	// 管理-云原生管理-ConfigMap-创建
	CreateConfigMap(ctx context.Context, in *CreateConfigMapRequest, opts ...grpc.CallOption) (*CreateConfigMapResponse, error)
	// 管理-云原生管理-ConfigMap-更新
	UpdateConfigMap(ctx context.Context, in *UpdateConfigMapRequest, opts ...grpc.CallOption) (*UpdateConfigMapResponse, error)
}

type configMapClient struct {
	cc grpc.ClientConnInterface
}

func NewConfigMapClient(cc grpc.ClientConnInterface) ConfigMapClient {
	return &configMapClient{cc}
}

func (c *configMapClient) ListConfigMap(ctx context.Context, in *ListConfigMapsRequest, opts ...grpc.CallOption) (*ListConfigMapsResponse, error) {
	out := new(ListConfigMapsResponse)
	err := c.cc.Invoke(ctx, ConfigMap_ListConfigMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMapClient) CreateOrUpdateConfigMapByYaml(ctx context.Context, in *CreateOrUpdateConfigMapByYamlRequest, opts ...grpc.CallOption) (*CreateOrUpdateConfigMapByYamlResponse, error) {
	out := new(CreateOrUpdateConfigMapByYamlResponse)
	err := c.cc.Invoke(ctx, ConfigMap_CreateOrUpdateConfigMapByYaml_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMapClient) DeleteConfigMap(ctx context.Context, in *DeleteConfigMapRequest, opts ...grpc.CallOption) (*DeleteConfigMapResponse, error) {
	out := new(DeleteConfigMapResponse)
	err := c.cc.Invoke(ctx, ConfigMap_DeleteConfigMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMapClient) GetConfigMapDetail(ctx context.Context, in *ConfigMapDetailRequest, opts ...grpc.CallOption) (*ConfigMapDetailResponse, error) {
	out := new(ConfigMapDetailResponse)
	err := c.cc.Invoke(ctx, ConfigMap_GetConfigMapDetail_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMapClient) CreateConfigMap(ctx context.Context, in *CreateConfigMapRequest, opts ...grpc.CallOption) (*CreateConfigMapResponse, error) {
	out := new(CreateConfigMapResponse)
	err := c.cc.Invoke(ctx, ConfigMap_CreateConfigMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *configMapClient) UpdateConfigMap(ctx context.Context, in *UpdateConfigMapRequest, opts ...grpc.CallOption) (*UpdateConfigMapResponse, error) {
	out := new(UpdateConfigMapResponse)
	err := c.cc.Invoke(ctx, ConfigMap_UpdateConfigMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConfigMapServer is the server API for ConfigMap service.
// All implementations must embed UnimplementedConfigMapServer
// for forward compatibility
type ConfigMapServer interface {
	// 查看-云原生管理-ConfigMap-列表
	ListConfigMap(context.Context, *ListConfigMapsRequest) (*ListConfigMapsResponse, error)
	// 管理-云原生管理-ConfigMap-Yaml创建更新
	CreateOrUpdateConfigMapByYaml(context.Context, *CreateOrUpdateConfigMapByYamlRequest) (*CreateOrUpdateConfigMapByYamlResponse, error)
	// 管理-云原生管理-ConfigMap-删除
	DeleteConfigMap(context.Context, *DeleteConfigMapRequest) (*DeleteConfigMapResponse, error)
	// 查看-云原生管理-ConfigMap-详情
	GetConfigMapDetail(context.Context, *ConfigMapDetailRequest) (*ConfigMapDetailResponse, error)
	// 管理-云原生管理-ConfigMap-创建
	CreateConfigMap(context.Context, *CreateConfigMapRequest) (*CreateConfigMapResponse, error)
	// 管理-云原生管理-ConfigMap-更新
	UpdateConfigMap(context.Context, *UpdateConfigMapRequest) (*UpdateConfigMapResponse, error)
	mustEmbedUnimplementedConfigMapServer()
}

// UnimplementedConfigMapServer must be embedded to have forward compatible implementations.
type UnimplementedConfigMapServer struct {
}

func (UnimplementedConfigMapServer) ListConfigMap(context.Context, *ListConfigMapsRequest) (*ListConfigMapsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConfigMap not implemented")
}
func (UnimplementedConfigMapServer) CreateOrUpdateConfigMapByYaml(context.Context, *CreateOrUpdateConfigMapByYamlRequest) (*CreateOrUpdateConfigMapByYamlResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateConfigMapByYaml not implemented")
}
func (UnimplementedConfigMapServer) DeleteConfigMap(context.Context, *DeleteConfigMapRequest) (*DeleteConfigMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConfigMap not implemented")
}
func (UnimplementedConfigMapServer) GetConfigMapDetail(context.Context, *ConfigMapDetailRequest) (*ConfigMapDetailResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfigMapDetail not implemented")
}
func (UnimplementedConfigMapServer) CreateConfigMap(context.Context, *CreateConfigMapRequest) (*CreateConfigMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConfigMap not implemented")
}
func (UnimplementedConfigMapServer) UpdateConfigMap(context.Context, *UpdateConfigMapRequest) (*UpdateConfigMapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfigMap not implemented")
}
func (UnimplementedConfigMapServer) mustEmbedUnimplementedConfigMapServer() {}

// UnsafeConfigMapServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConfigMapServer will
// result in compilation errors.
type UnsafeConfigMapServer interface {
	mustEmbedUnimplementedConfigMapServer()
}

func RegisterConfigMapServer(s grpc.ServiceRegistrar, srv ConfigMapServer) {
	s.RegisterService(&ConfigMap_ServiceDesc, srv)
}

func _ConfigMap_ListConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConfigMapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMapServer).ListConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigMap_ListConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMapServer).ListConfigMap(ctx, req.(*ListConfigMapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMap_CreateOrUpdateConfigMapByYaml_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrUpdateConfigMapByYamlRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMapServer).CreateOrUpdateConfigMapByYaml(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigMap_CreateOrUpdateConfigMapByYaml_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMapServer).CreateOrUpdateConfigMapByYaml(ctx, req.(*CreateOrUpdateConfigMapByYamlRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMap_DeleteConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConfigMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMapServer).DeleteConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigMap_DeleteConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMapServer).DeleteConfigMap(ctx, req.(*DeleteConfigMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMap_GetConfigMapDetail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigMapDetailRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMapServer).GetConfigMapDetail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigMap_GetConfigMapDetail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMapServer).GetConfigMapDetail(ctx, req.(*ConfigMapDetailRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMap_CreateConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConfigMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMapServer).CreateConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigMap_CreateConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMapServer).CreateConfigMap(ctx, req.(*CreateConfigMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConfigMap_UpdateConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateConfigMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConfigMapServer).UpdateConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConfigMap_UpdateConfigMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConfigMapServer).UpdateConfigMap(ctx, req.(*UpdateConfigMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConfigMap_ServiceDesc is the grpc.ServiceDesc for ConfigMap service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConfigMap_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "configmap.v1.ConfigMap",
	HandlerType: (*ConfigMapServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListConfigMap",
			Handler:    _ConfigMap_ListConfigMap_Handler,
		},
		{
			MethodName: "CreateOrUpdateConfigMapByYaml",
			Handler:    _ConfigMap_CreateOrUpdateConfigMapByYaml_Handler,
		},
		{
			MethodName: "DeleteConfigMap",
			Handler:    _ConfigMap_DeleteConfigMap_Handler,
		},
		{
			MethodName: "GetConfigMapDetail",
			Handler:    _ConfigMap_GetConfigMapDetail_Handler,
		},
		{
			MethodName: "CreateConfigMap",
			Handler:    _ConfigMap_CreateConfigMap_Handler,
		},
		{
			MethodName: "UpdateConfigMap",
			Handler:    _ConfigMap_UpdateConfigMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "pb/configmap.v1.proto",
}
